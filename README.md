# Description of the problem

A squad of robotic rovers are to be landed by NASA on a plateau on Mars. This plateau, which is curiously rectangular, must be navigated by the rovers so that their on-board cameras can get a complete view of the surrounding terrain to send back to Earth.
A rover's position and location is represented by a combination of x and y co-ordinates and a letter representing one of the four cardinal compass points. The plateau is divided up into a grid to simplify navigation. An example position might be 0, 0, N, which means the rover is in the bottom left corner and facing North.
In order to control a rover, NASA sends a simple string of letters. The possible letters are 'L', 'R' and 'M'. 'L' and 'R' makes the rover spin 90 degrees left or right respectively, without moving from its current spot. 'M' means move forward one grid point, and maintain the same heading.
Assume that the square directly North from (x, y) is (x, y+1).
## Input
The first line of input is the upper-right coordinates of the plateau, the lower-left coordinates are assumed to be 0,0.
The rest of the input is information pertaining to the rovers that have been deployed. Each rover has two lines of input. The first line gives the rover's position, and the second line is a series of instructions telling the rover how to explore the plateau. The position is made up of two integers and a letter separated by spaces, corresponding to the x and y co-ordinates and the rover's
orientation.
Each rover will be finished sequentially, which means that the second rover won't start to move until the first one has finished moving. 
## Output
The output for each rover should be its final co-ordinates and heading.
## Test Input
5 5

1 2 N

LMLMLMLMM

3 3 E
MMRMMRMRRM
## Expected Output
1 3 N

5 1 E

# Instructions

To compile the code, generate the jar file and execute the automated tests run: mvn clean install
To execute the jar file generated by the previous command go to the taget folder of the project and run: 
    java -DpathToFile=C:\full\path\to\file.txt -jar rover.jar

# Folder Structure

The workspace contains two folders by default, where:

- `src` : the folder to maintain sources
  - `enums` : this folder contains all the enums used in the project
  - `exceptions` : this folder contains custom exceptions
  - `models` : this folder contains objects and structures of this project
  - `service` : this folder contains classes that manipulate and facilitate the handling of data in the project
- `test` : this folder contains Unit tests for each class and a integration test of the app.

# Application Flow
  - First we start defining enums:
    - Heading which will describe the direction the rover is facing. Values = {N,S,E,W}
    - Movements which are the allowable movements. Values = {L,R,M}
  - The application starts defining 3 model classes:
    - Grid, which contains a specification of the Grid(X, Y).
    - Placement which contains the placement the rover will gave, with an X and Y position and a Heading
    - Rover, which is the rover entity, having as atributes the Grid in which it will run. Its placement and a roverNumber variable to keep track of rover order. Also describes the movement logic, depending on the movement itself and the heading.
  - Then we have the 2 service classes:
    - FileUtilityService is responsible for facilitate the manipulation of file data and interpret the data inside it
    - RoverPathResolverService is responsible for mapping all the rovers and resolving their paths throughout their movements.
  - Finally the Application main file is responsible for fitting those services togheter.
  We start by reading the file and separating it into lines.
  The 0th line is the grid dimensions.
  For each rover:
    Line 1 are converted to placements.
    Line 2 and all other even lines are converted into a list of movements that the current rover will execute.
    Then we add the rover to the roverMap, returning a key of its position.
    Then this rover will execute its list of movements.

Finally we read all the results from the roverMap and order them by rover number to display the final result.

# Tests
  - Each class created contains its own unit test
  - Unit test covers all prossible branches, getting 100% coverage on code (except usual and very simple functions(getters, setters, equal, toString))
    - OBS: REALLY WANTED TO USE LOMBOK HERE
    - OBS: If I could use lombok I would also use openPojo automated tests, unfortunatelly my autogenerated setters and getters do not follow openPojo patterns
  - Finally the AppTest, tests the main flows of the program.

# Dependencies
  - JUnit 5 for automated testing
  - Maven java plugin to build a jar file
  - Surefire to get reports and run automated testing when building

# Assumption list
  - Considering the 2d grid, a rover cannot occupy or pass through the same space as another rover is parked on. That will throw an exception.
  - Going off grid is not a valid state and will throw and exception.
  - Line 0 need to have two integers separated by a space, not having that will throw a file format exception.
  - Line 1 and all subsequent odd lines will be 3 elements separated by a space, two integers and a character of allowable value = {W,E,N,S}respectively, anything differing from that pattern will throw an file out of expected format exception.
  - Line 2 and all subsequent even lines will be a list of movement comands with allowableValues = {L,R,M} any character diverging from that will throw an exception. It is a valid assumption that even lines may come empty, meaning that the rover won't move.
  - File path needs to be correctly provided, the program will throw an exception in case it does no find the file in the specified path.
  - A 5x6 grid is able to place in x from 0 to 5 and in y from 0 to 6
  - Each rover occupies a unique position in a hash map, their key is a long calculated using the formula: xposition*((Grid X limit)*(Grid Y limit)) + yposition. 
    - Java specifies a long as 8 bytes, taking off all the negative numbers the domain would be from 0 to 9,223,372,036,854,775,807.
    - This gives us an inequation that needs to be respected: (xGridSize^2 * yGridSize) + yGridSize < 9,223,372,036,854,775,807.

