## Instructions

To compile the code, generate the jar file and execute the automated tests run: mvn clean install
To execute the jar file generated by the previous command go to the taget folder of the project and run: 
    java -DpathToFile=C:\full\path\to\file.txt -jar rover.jar

## Folder Structure

The workspace contains two folders by default, where:

- `src` : the folder to maintain sources
  - `enums` : this folder contains all the enums used in the project
  - `exceptions` : this folder contains custom exceptions
  - `models` : this folder contains objects and structures of this project
  - `service` : this folder contains classes that manipulate and facilitate the handling of data in the project
- `test` : this folder contains Unit tests for each class and a integration test of the app.

## Application Flow
  - First we start defining enums:
    - Heading which will describe the direction the rover is facing. Values = {N,S,E,W}
    - Movements which are the allowable movements. Values = {L,R,M}
  - The application starts defining 3 model classes:
    - Grid, which contains a specification of the Grid(X, Y).
    - Placement which contains the placement the rover will gave, with an X and Y position and a Heading
    - Rover, which is the rover entity, having as atributes the Grid in which it will run. Its placement and a roverNumber variable to keep track of rover order. Also describes the movement logic, depending on the movement itself and the heading.
  - Then we have the 2 service classes:
    - FileUtilityService is responsible for facilitate the manipulation of file data and interpret the data inside it
    - RoverPathResolverService is responsible for mapping all the rovers and resolving their paths throughout their movements.
  - Finally the Application main file is responsible for fitting those services togheter.
  We start by reading the file and separating it into lines.
  The 0th line is the grid dimensions.
  For each rover:
    Line 1 are converted to placements.
    Line 2 and all other even lines are converted into a list of movements that the current rover will execute.
    Then we add the rover to the roverMap, returning a key of its position.
    Then this rover will execute its list of movements.

Finally we read all the results from the roverMap and order them by rover number to display the final result.

## Tests
  - Each class created contains its own unit test
  - Unit test covers all prossible branches, getting 100% coverage on code (except usual and very simple functions(getters, setters, equal, toString))
    - OBS: REALLY WANTED TO USE LOMBOK HERE
    - OBS: If I could use lombok I would also use openPojo automated tests, unfortunatelly my autogenerated setters and getters do not follow openPojo patterns
  - Finally the AppTest, tests the main flows of the program.

## Dependencies
  - JUnit 5 for automated testing
  - Maven java plugin to build a jar file
  - Surefire to get reports and run automated testing when building

## Assumption list
  - Considering the 2d grid, a rover cannot occupy or pass through the same space as another rover is parked on. That will throw an exception.
  - Going off grid is not a valid state and will throw and exception.
  - Line 0 need to have two integers separated by a space, not having that will throw a file format exception.
  - Line 1 and all subsequent odd lines will be 3 elements separated by a space, two integers and a character of allowable value = {W,E,N,S}respectively, anything differing from that pattern will throw an file out of expected format exception.
  - Line 2 and all subsequent even lines will be a list of movement comands with allowableValues = {L,R,M} any character diverging from that will throw an exception. It is a valid assumption that even lines may come empty, meaning that the rover won't move.
  - File path needs to be correctly provided, the program will throw an exception in case it does no find the file in the specified path.
  - A 5x6 grid is able to place in x from 0 to 5 and in y from 0 to 6
  - Each rover occupies a unique position in a hash map, their key is a long calculated using the formula: xposition*((Grid X limit)*(Grid Y limit)) + yposition. 
    - Java specifies a long as 8 bytes, taking off all the negative numbers the domain would be from 0 to 9,223,372,036,854,775,807.
    - This gives us an inequation that needs to be respected: (xGridSize^2 * yGridSize) + yGridSize < 9,223,372,036,854,775,807.

